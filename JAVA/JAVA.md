## JAVA  문법 정리

>
>
>객체 지향 프로그램 
>
>객체화
>
>자료형 
>
>class 테두리 안에 존재



**특징**

* 클래스 안에 함수 메소드가 있다
* class라 써야하고 파일명은 동일해야 한다 
* 함수 안에 명령어를 써야한다, 함수는 명령어들의 집함
* 클래스명의 첫 글자는 대문자로 시작 
* 단어가 결합 시, 대문자로 시작 > GoodMorning 
* main 메소드를 꼭 갖는다 



**기본형**

```
class (클래스명) {
	public static void manin (String[]args){
	
	}
}
```



출력시 |  콘솔 _ System

​			 입력 _ System.in

​			출력 _ System.out

``` 
class 클래스명{ 

         public static void main(String[]args){

           System.out.print();  

         }

}
```





**컴파일**

- 컴퓨터가 알수 있게 번역해주는 과정이 컴파일 
- 언어마다 다른 컴파일러가 있다. 



HelloWorld.java                              소스파일_사람은 알고, 기계는 모르는 상태 

​        ↓  컴파일                                 javac 클래스명.java 

HelloWorld.class     

​        ↓ 실행                                      java 클래스명 _ 실행할때, 확장명을 쓰지 않음 

HelloWorld.exe(xxxx)                      자바는 실행파일없다. 







*다양한 기능들*

> *  띄어쓰기 
>
> ​                      \n                                                  
>
> ​                     println                                            ex) System.out.println();      > 한칸 띄우라는  
>
> * TAB 기능  : \t 를 쓰면 Tab의 기능을 함 





---





* 정수 타입 : 정수를 저장할 수 있는 타입으로 Byte, Short, int, long 타입을 뜻함 

* char 타입 :  작은 따옴표로 감싼 하나의 문자 리터럴을 저장 할수 있는 타입 

* String 타입 :  큰 따옴표로 감싼 문자열을 저장할 수 있는 타입 

* 실수 타입 :  실수를 저장 할 수 있는 타입으로 _ Float, Double 

* Boolean 타입 :  참과 거짓을 의미하는 true, false를 저장 



## **정수와 실수**

정수 : 소수점 x / 실수 : 소수점 o  (자바랑 c언어에서는 이 둘을 구분해야함) 

*  정수/정수 -> 정수                                         정수/실수 -> 실수 

* format : 형식을 지정

* 문자열 : %s

* 실수 : %f 

* 정수 : %d

* 문자 : %c



## **문자와 문자열**



2 : 숫자 

'2' : 문자  (한 개의 글자)  _ : 65

"2" : 문자열  - "A" : 65(x) 그냥 문자 A로 봄 

System.out.println(25+36);  >>>>>>>> 61 

System.out.println("25+36"); >>>>>>> 25+36

System.out.println("25"+"36");>>>>>>>>2536



---

# 제어문

위에서 아래로 처리되는 명령어의 처리 순서를 변경 시키는 문장 



## 조건문 : 조건에 따라 지정한 실행 구문 수행 

## - if문  

> 조건문이 ture일 때만 실행 
>
> else if : if 가 false면 다음 꺼, 다되면 멈춤
>
> else : 모든 경우의 마지막, 앞계산식이 다 아닐경우 실행  

## switch 문 

> 변수값이 설정한 데이터가 같을 때 실행





---





## 반복문 : 설정한 조건식이 true면 실행구문을 반복 수행함 



## for문 

형식 

> for ( 변수명 = 초기화식 ; 조건식 ; 증감식; ) 
>
> 조건식이 true가 될 때까지만 중괄호 내부를 반복 실행, 반복할때마다 증감식이 실행 되고, 초기화식은 조건식과 
>
> 증감식에서 사용할 루프 카운터 변수를 초기화 합니다. 지정된 횟수만큼 반복할 때 사용 

```
* for문을 이용해 3의 배수의 총합을 구하라 

public static void main(String[] args) {
int num = 0;
		
		
		for(int z = 1; z<= 100; z++ ){
			if(z% 3 ==0 ) {
				num += z;
			
			}
		}
	
		System.out.println("3의 배수  " +  num);
	}
	}
```





* while문 : while(조건식) : 조건식이 true 될 때까지만 중괄호 내부를 반복 실행함 
* do - while : do { ,,, } while(조건식)  이며 먼저 do 중괄호 내부를 실행하고 그 다음 조건식이 true가 되면 다시 중괄호 내부를 반복 실행
* break 문 : for문, while문, do- while문 내부에서 실행되면 반복을 취소함
* continue문 : for문, while문, do-while문 내부에서 실행되면 증감식 또는 조건식으로 돌아감 





##  

---



# 객체 지향 프로그래밍 #



## 객체 ##

 

​      :  물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있으면서 식별 가능한 것  

> 객체는 속성과 동작으로 구성 ( ex 사람은 이름, 나이등의 속성, 걷다 등의 동작 )
>
> 자바는 이 속성과 동작을 각각 필드와 메소드라고 부른다. 



## 클래스 ##



> 객체를 정의 해 놓은 것 
>
> 객체를 생성하는데 사용 

클래스로 부터 만들어진 객체를 해당 클래스의 인스턴스라고 함  ( 객체와 인스턴스는  거의 비슷하다고 보면 된다고함... )

``` 
쿨래스 ------------------ >  인스턴스(객체)
           인스턴스화 
```



* 클래스를 설계 > 설계된 클래스를 가지고 사용할 객체를 생성 > 생성된 객체를 이용 

* 클래스가 왜 필요한가 >  객체를 생성하기 위해 



< 클래스 선언 > 

``` 
public class (클래스 이름 ){ 
}
```







## 객체의 생성 

클래스명 변수명 ;           > 클래스의 객체를 참조하기 위한 참조 변수를 선언 

변수명 = new 클래스명( );     >클래스의 객체를 생성 후, 객체의 주소를 참조 변수에 저장  



[클래스의 구성  ]

``` 
public class ClassName {

int fieldname ;         > 필드 : 객체의 데이터가 저장되는 곳   


ClassName( ) {         > 생성자 : 객체 생성시 초기화 담당 

}

void methodName ( ) {    > 메소드 : 객체의 동작에 해당하는 실행 블록 

   }
}
```



## 생성자 ##

>  new 연산자로 클래스로부터 객체를 생성할 때, 호출되어 객체의 초기화를 담당 함 



* 기본 생성자 :  클래스 선언 시, 컴파일러에 의해 자동으로 추가되는 생성자 
* 생성자 선언 :  클래스로부터 객체를 생성 할 때, 호출되는 생성자를 명시적으로 선언 할 수 있고, 생성자를 선언하면 기본 생성자는 생성되지 않음 
* 매개변수 : 생성자 호출 시 값을 전달 받기 위해 선언되는 변수 
* 객체 초기화 :  필드를 초기화 하거나 메소드를 호출해서 객체를 사용할 준비를 하는 것 
* this() : 객체 자신의 또 다른 생정자를 호출 할 때 사용 



## 메서드 ## 

> 문장들을 묶어 놓은 것  , 객체의 동작에 해당하는 중괄호 { } 블록을 말한다. 블록이름이 메소드 이름이며, 호출하면 일괄적으로 실행  
>
> 중복코드 제거, 관리 용이, 재사용 가능 
>
> 메세드 = 선언부 + 구현부  

[ 메소드의 구조 ] 

``` 
public 리턴자료형 메서드명(입력자료형1 입력변수1, 입력자료형2 입력변수2, ...) {
    ...    
    return 리턴값;  // 리턴자료형이 void 인 경우에는 return 문이 필요없다.
}  > 리턴자료형은 메서드 수행 후 돌려줄 값의 자료형을 의미한다. 메서드의 리턴값은 return 이라는 명령을 사용한다.
```



[메서드 호출 ] _  클래스 내외부의 호출에 의해 실행 

클래스 내부의 다른 메서드에서 호출할 경우, 단순한 메서드 이름으로 호출 되지만 외부에서 호출 할 경우 클래스로 부터 객체를 생성한 뒤 참조 변수를 이용해 

메서드를 호출 해야하고, 객체가 존재해야 메서드도 존재하기 때문.



## 메서드의 실행 흐름 #



``` 
math mm = new math();     //인스턴스 생성
long value = mm.add(1L,2L);  // 메소드 호출 

long add ( long a, long b ){
 	long result = a + b; 
 	return result; 
}
```

> 메인 메서드에서 메서드 add 를 호출 한다, 인수 1L과 2L이 메서드 add의 매개변수 a, b에 각각 대입된다
>
> 메서드 add의 괄호{ } 안에 있는 문장들이 순서대로 수행된다
>
> 메서드 add의 모든 문장이 실행되거나 return문을 만나면, 호출한 메서드로 되돌아와서 이후의 문장들을 실행 

* void : 리턴값이 없는 메소드는 리턴 타입으로 void를 기술 해야함
* 리턴문 :  선언부에 리턴타입이 있다면 리턴값을 지정하기 위해 return문이 반드시 있어야하고, void라면 필요 없지만 메서드 실행 종료를 위해 사용할수도 있다
* 오버로딩 :  클래스 내에 같은 이름의 메소드를 여러개 선언 하는 것을 메서드 오버로딩이라고 함, 메서드 오버로딩의 조건은 매개 변수의 타입, 개수, 순서 중 하나가 달라야 한다







* 인스턴스 멤버  :  인스턴스 멤버란 객체를 생성한 후 사용할 수 있는 필드와 메서드를 말하는데 이들을 각각 인스턴스필드, 인스턴스 메서드라고 부름 

* this : 객체 내부에서도 인스턴스 멥버에 접근하기 위해 this를 사용 할 수 있고, 예를 들어 this.model은 자신이 가지고 있는  model 필드라는 뜻, this는 주로 생성자와 메서드의 매개변수 이름이 필드와 동일한 경우 인스턴스 멤버인 필드임을 명시하고자 할때 사용 

* 정적 멤버 :  클래스에 고정된 멤버로서 객체를 생성하지 않고 사용 할 수 있는 필드와 메서드를 말하고, 정적 필드, 정적 메서드라고 함

* static 정적 멤버를 선언할 때 사용하는 키워드 

* 싱글톤 :  전체 프로그램에서 단 하나의 객체만 만들도록 보장해야하는 경우 하나만 생성된다고 해서 객체를 싱글톤이라고 함 

  > 싱글톤을 만들려면 클래스 외부에서 new 연산자로 생성자를 호출 할 수 없도록 막아햐 함, 생성자를 호출한 만큼 객체가 생성되기 때문, private 접근 제한자 붙여주면 됨
  >
  > > 코드 작성 
  > >
  > > ```
  > > public class 클래스 {
  > > 
  > > private static 클래스 singleton = new 클래스 ();  >>>>>>정적 필드 
  > > 
  > > private 클래스 () {} >>>>>>>>>생성자 
  > > 
  > > static 클래스 getInstance() {
  > >  return signleton; 
  > > }
  > > }
  > > ```





* 패키지 : 해당 클래스 또는 인터페이스가 어떤 패키지에 속할 것인지 선언하는 것 
* import문 : 사용하고자 하는 클래스 또는 인터페이스가 다른 패키지에 소속되어 있다면, import 문으로 해당 패키지의 클래스 또는 인터네이스를 가져와 사용할 것임을 컴파일러에게 알려줘야함 



# 접근 제한자

> 클래스와 인터페이스를 다른 패키지에서 사용하지 못하도록 막을 필요가 있고, 객체 생성을 막기 위해 생성자를 호출 하지 못하게 하거나 필드나 메서드를 사용하지 못하도록 막아야 하는 경우 >  접근자 사용
>
>  접근제한               적용대상                           접근할수 없는 클래스 
>
> public  >      클래스, 필드, 생성자, 메서드  >          없음 
>
> protected >   필드 , 생성자, 메서드  >               자식 클래스가 아닌 다른 패키지에 소속된 클래스 
>
> default >        클래스, 필드, 생성자, 메서드 >  다른 패키지에 소속된 클래스 
>
> private >       필드, 생성자, 메서드 >          모든 외부 클래스 



* getter / setter  :  필드는 외부에서 접근 할 수 없도록 막고 메서드는 공개해서 외부에서 메소드를 통해 필드에 접근하도록 유도, 필드의 값을 외부로 리턴 해주는 메서드를  getter, 외부에서 값을 받아 필드를 변경하는 메서드를 setter라고 함





## 캡슐화

= 외부로부터 데이터를 보호하기 위해서, 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해   



```
public class member {

	private String id;
	private String pw;
	private int age;

	//getter
	public String getId() {
		return id;
	}
	public String getPw() {
		return pw;
	}
	public int getAge() {
		return age;
	}

	//setter
	public void setId(String id) {
		this.id = id;
	}
	public void setPw(String pw) {
		this.pw = pw;
	}
	public void setAge(int age) {
		this.age = age;
	}
}
```

> 멤버 클래스의 모든 변수는 private으로 접근제어자 선언을 해놓았기 때문에 멤버 클래스 내부에서만 접근 가능, 접근을 위해 setter 와 getter라는 장치를 만들어서 내부에 접근 가능함 

---









## 상속 ( Inheritance )

> 기존의 클래스로 새로운 클래스를 작성하는 것( 코드의 재사용)
>
> 두 클래스를 부모와 자식으로 관계를 맺어주는 것  

``` 
Class 자식클래스 extends 부모클래스 { 
//필드
//생성자
//메소드 
}
```



* super 예약어 :  자식 내부에서 부모의 멤버 ( 속성변수, 메소드, 생성자)를 호출하기 위해 사용, 반드시 자식의 생성자  첫줄에 부모 생성자를 호출하는 super(~) 가 있어야 함 ( 없으면 자바가 자동 삽입 ) super(~ ) 무조건 생성자 안에서만 나오는 것, 메소드 안에서는 나올 수 없음 
* 자식은 부모의 모든 멤버를 상속 받는다 ( 생성자, 초기화 제외)
* 자식의 멤배 개수는 조상보다 적을 수 없다 ( 같거나 많다 )







## 다형성 

> 여러 가지 형태를 가질 수 있는  ( 부모 타입 참조 변수로 자손 타입 객체를 다루는 것 )
>
> 객체 사용방법은 동일하지만, 실행결과가 다양하게 나오는 성질을 말함, 다형성을 구현하는 기술은 메서드 재정의와 타입 변환이고, 자식객체가 재정의된 메서드를 가지고 있을 경우, 부모타입으로 자동 타입 변환 후에 메서드를 호출 하면 재정의된 자식 메서드가 호출 되면서 다양한 결과를 가져옴 



## 추상 (abstract)

>미완성 설계도, 미완성 메서드를 갖고 있는 클래스  
>
>바디가 없는 메소드를 한개이상 소유하고 있거나 부모 클래스가 바디 없는 메소드를 한개 이상 소유 하고 있는 클래스 ( 그러나 부모 클래스부터 자기 클래스 사이에 이 메소드를 재정의 하지 않았을 경우에만 해당 )
>
>추상 클래스 이름 앞에 final 붙을 수 없음 
>
>객체화 할 수 없다. > 메소드 호출이 불가능 하기 때문에 
>
>추상클래스의 메소드를 자식이 전부 재정의 하면 일반 클래스가 되어 객체화 가능함 



## 인터페이스  ( Interface )

>public,static,final 성격을 가진 속성변수와 public, abstract 성격을 가진 메소드만으로 구성된 단위프로그램  
>
>인터페이스에 정의한 추상 메서드를 다른 클래스에서 재정의 해서 사용함 
>
>```
>인터페이스 선언 
>public interface 인터페이스이름 { ... } 
>```
>
>인터페이스는 상수필드, 추상메소드 만을 구성 멤버로 가짐 >  객체로 생성할수 없기 때문에 생성자를 가질수 없음 
>
>implements :  인터페이스가 다른 클래스에게 멤버를 물려주는 것.단, 클래스는 인터페이스에게 받은 추상메소드를 조상까지 전부 재정의 해야 한다. 그래야 객체화 할 수 있다.메소드를 재정의할 때에는 public을 붙여야 한다. 단, 인터페이스는 final 성격을 가지고 있어서 클래스가 인터페이스의 속성변수를 가져올수는 있는데, 갱신은 못한다. 
>
>``` 
>구현 클래스 
>public class 구현클래스 implements 인터페이스이흠 { 
> // 인터페이스에 선언된 추상 메서드의 실체 메서드 선언 
>}
>```
>
>인터페이스 사용 : 클래스를 선언할 떄, 인터페이스는 필드, 생성자 또는 메서드의 매개변수, 생성자 또는 메서드의 로컬 변수로 선언 될 수 있다.
>
>* 인터페이스가 필드 타입으로 사용될 경우 :  필드에 구현 객체를 대입
>* 인터페이스가 생성자의 매개 변수 타입으로 사용될 경우 : new 연산자로 객체를 생성할 때,, 구현 객체를 생성자의 매개값으로 대입 
>* 인터페이스가 로컬 변수 타입으로 사용될 경우 :  변수에 구현 객체를 대입 
>* 인터페이스가 메서드의 매개 변수 타입으로 사용될 경우 :  메서드 호출 시  구현 객체를 매개값으로 대입 



## 오버로딩 vs 오버 라이딩

- 오버로딩  : 생성자 오버로딩) 같은 이름의 생성자를 2개 이상 정의하는 것으로, [생성자명]은 같더라도 [매개변수의 갯수]나 [매개변수의 자료형]은 달라야함 
- 오버라이딩 : 부모의 메소드를 자식이 같은 이름으로 재정의하는 것 , 인터페이스에 계획된 메소드명을 만들고 클래스가 이 메소드 이름만 그대로 가져다 실행구문을 설정하는 것으로 계획된 메소드로 구성된 클래스를 만들 수 있음 단 , 메소드 앞에 final이 있으면 불가. 



---



# 제네릭(Generic) 

> 변수의 선언이나 메서드의 매개변수를 하나의 참조 자료형이 아닌 여러 자료형을 변환 될수 있도록 ... 
>
> 타입을 파라미터화 해서 컴파일시 구체적인 타입이 결정되는 것  
>
> ``` 
> HashMap<String,String> map = new HashMap <String, String>(); 
> 
> 
> ArrayList list = new ArrayList(); //제네릭을 사용하지 않을경우
> list.add("test");
> String temp = (String) list.get(0); //타입변환이 필요함
>         
> ArrayList<String> list2 = new ArrayList(); //제네릭을 사용할 경우
> list2.add("test");
> temp = list2.get(0); //타입변환이 필요없음 
> ```
>
>  컬렉션, 람다식, 스트림, NIO에서 사용되니까 확실하게 이해 필요

* 컴파일시 강한 타입 체크를 할 수 있다 

* 타입변환을 제거 할 수 있다.

* "<>"부호가 붙고 사이에는 타입 파라미터가 위치해야한다  

  ``` 
  public class 클래스명<T> { ...}
  public interface 인터페이스명<T>{ ...}
  ```

  ```
  타입인자	설명
  <T>	        Type
  <E>       	Element
  <K>     	Key
  <N>     	Number
  <V>	        Value
  <R>	        Result
  ```

  

---



# 컬렉션 프레임워크

> 사전적 의미로 객체를 수집해서 저장하는 것 , 프레임워크는 사용방법을 미리 정해놓은 라이브러리. 

* LIST  _  배열과 유사하게 인덱스로 관리
* SET _ 집합과 유사
* MAP _ 키와 값의 쌍으로 관리 

### LIST 컬렉션 

> 객체를 일렬로 늘어놓는 구조를 가지고 있음. 
>
> 인덱스로 객채를 검색, 삭제 가능 
>
> ArrayList, Vector, LinkedList 
>
> 단방향 포인터 구조로 각 데이터에 대한 인덱스를 가지고 있어 조회 기능에 성능이 뛰어남 
>
> ```
> // String 객체를 관리하는 ArrayList 생성
> List<String> list = new ArrayList();
> 
> // String 객체 저장
> list.add("Hello World");
> 
> // null 저장
> list.add(null); 
> 
> // 동일한 String 객체를 갖고 있는지 검색 
> boolean isFindValue = list.contains("Hello World");
> 
> // 인덱스 값을 이용하여 객체 삭제
> list.remove(0);
> 
> // List에 저장된 모든 객체를 얻어서 콘솔 창에 출력 
> for(String value : list) {
> 	System.out.println(value);
> }
> 
> ```
>
> 

