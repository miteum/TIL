## JAVA  문법 정리

>
>
>객체 지향 프로그램 
>
>객체화
>
>자료형 
>
>class 테두리 안에 존재



**특징**

* 클래스 안에 함수 메소드가 있다
* class라 써야하고 파일명은 동일해야 한다 
* 함수 안에 명령어를 써야한다, 함수는 명령어들의 집함
* 클래스명의 첫 글자는 대문자로 시작 
* 단어가 결합 시, 대문자로 시작 > GoodMorning 
* main 메소드를 꼭 갖는다 



**기본형**

```
class (클래스명) {
	public static void manin (String[]args){
	
	}
}
```



출력시 |  콘솔 _ System

​			 입력 _ System.in

​			출력 _ System.out

``` 
class 클래스명{ 

         public static void main(String[]args){

           System.out.print();  

         }

}
```





**컴파일**

- 컴퓨터가 알수 있게 번역해주는 과정이 컴파일 
- 언어마다 다른 컴파일러가 있다. 



HelloWorld.java                              소스파일_사람은 알고, 기계는 모르는 상태 

​        ↓  컴파일                                 javac 클래스명.java 

HelloWorld.class     

​        ↓ 실행                                      java 클래스명 _ 실행할때, 확장명을 쓰지 않음 

HelloWorld.exe(xxxx)                      자바는 실행파일없다. 







*다양한 기능들*

> *  띄어쓰기 
>
> ​                      \n                                                  
>
> ​                     println                                            ex) System.out.println();      > 한칸 띄우라는  
>
> * TAB 기능  : \t 를 쓰면 Tab의 기능을 함 





---





* 정수 타입 : 정수를 저장할 수 있는 타입으로 Byte, Short, int, long 타입을 뜻함 

* char 타입 :  작은 따옴표로 감싼 하나의 문자 리터럴을 저장 할수 있는 타입 

* String 타입 :  큰 따옴표로 감싼 문자열을 저장할 수 있는 타입 

* 실수 타입 :  실수를 저장 할 수 있는 타입으로 _ Float, Double 

* Boolean 타입 :  참과 거짓을 의미하는 true, false를 저장 



## **정수와 실수**

정수 : 소수점 x / 실수 : 소수점 o  (자바랑 c언어에서는 이 둘을 구분해야함) 

*  정수/정수 -> 정수                                         정수/실수 -> 실수 

* format : 형식을 지정

* 문자열 : %s

* 실수 : %f 

* 정수 : %d

* 문자 : %c



## **문자와 문자열**



2 : 숫자 

'2' : 문자  (한 개의 글자)  _ : 65

"2" : 문자열  - "A" : 65(x) 그냥 문자 A로 봄 

System.out.println(25+36);  >>>>>>>> 61 

System.out.println("25+36"); >>>>>>> 25+36

System.out.println("25"+"36");>>>>>>>>2536



---

# 제어문

위에서 아래로 처리되는 명령어의 처리 순서를 변경 시키는 문장 



## 조건문 : 조건에 따라 지정한 실행 구문 수행 

## - if문  

> 조건문이 ture일 때만 실행 
>
> else if : if 가 false면 다음 꺼, 다되면 멈춤
>
> else : 모든 경우의 마지막, 앞계산식이 다 아닐경우 실행  

## switch 문 

> 변수값이 설정한 데이터가 같을 때 실행





---





## 반복문 : 설정한 조건식이 true면 실행구문을 반복 수행함 



## for문 

형식 

> for ( 변수명 = 초기화식 ; 조건식 ; 증감식; ) 
>
> 조건식이 true가 될 때까지만 중괄호 내부를 반복 실행, 반복할때마다 증감식이 실행 되고, 초기화식은 조건식과 
>
> 증감식에서 사용할 루프 카운터 변수를 초기화 합니다. 지정된 횟수만큼 반복할 때 사용 

```
* for문을 이용해 3의 배수의 총합을 구하라 

public static void main(String[] args) {
int num = 0;
		
		
		for(int z = 1; z<= 100; z++ ){
			if(z% 3 ==0 ) {
				num += z;
			
			}
		}
	
		System.out.println("3의 배수  " +  num);
	}
	}
```





* while문 : while(조건식) : 조건식이 true 될 때까지만 중괄호 내부를 반복 실행함 
* do - while : do { ,,, } while(조건식)  이며 먼저 do 중괄호 내부를 실행하고 그 다음 조건식이 true가 되면 다시 중괄호 내부를 반복 실행
* break 문 : for문, while문, do- while문 내부에서 실행되면 반복을 취소함
* continue문 : for문, while문, do-while문 내부에서 실행되면 증감식 또는 조건식으로 돌아감 





##  

---



# 객체 지향 프로그래밍 #



## 객체 ##

 

​      :  물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있으면서 식별 가능한 것  

> 객체는 속성과 동작으로 구성 ( ex 사람은 이름, 나이등의 속성, 걷다 등의 동작 )
>
> 자바는 이 속성과 동작을 각각 필드와 메소드라고 부른다. 



## 클래스 ##



> 객체를 정의 해 놓은 것 
>
> 객체를 생성하는데 사용 

클래스로 부터 만들어진 객체를 해당 클래스의 인스턴스라고 함  ( 객체와 인스턴스는  거의 비슷하다고 보면 된다고함... )

``` 
쿨래스 ------------------ >  인스턴스(객체)
           인스턴스화 
```



* 클래스를 설계 > 설계된 클래스를 가지고 사용할 객체를 생성 > 생성된 객체를 이용 

* 클래스가 왜 필요한가 >  객체를 생성하기 위해 



< 클래스 선언 > 

``` 
public class (클래스 이름 ){ 
}
```







## 객체의 생성 

클래스명 변수명 ;           > 클래스의 객체를 참조하기 위한 참조 변수를 선언 

변수명 = new 클래스명( );     >클래스의 객체를 생성 후, 객체의 주소를 참조 변수에 저장  



[클래스의 구성  ]

``` 
public class ClassName {

int fieldname ;         > 필드 : 객체의 데이터가 저장되는 곳   


ClassName( ) {         > 생성자 : 객체 생성시 초기화 담당 

}

void methodName ( ) {    > 메소드 : 객체의 동작에 해당하는 실행 블록 

   }
}
```



## 생성자 ##

>  new 연산자로 클래스로부터 객체를 생성할 때, 호출되어 객체의 초기화를 담당 함 



* 기본 생성자 :  클래스 선언 시, 컴파일러에 의해 자동으로 추가되는 생성자 
* 생성자 선언 :  클래스로부터 객체를 생성 할 때, 호출되는 생성자를 명시적으로 선언 할 수 있고, 생성자를 선언하면 기본 생성자는 생성되지 않음 
* 매개변수 : 생성자 호출 시 값을 전달 받기 위해 선언되는 변수 
* 객체 초기화 :  필드를 초기화 하거나 메소드를 호출해서 객체를 사용할 준비를 하는 것 
* this() : 객체 자신의 또 다른 생정자를 호출 할 때 사용 



## 메서드 ## 

> 문장들을 묶어 놓은 것  , 객체의 동작에 해당하는 중괄호 { } 블록을 말한다. 블록이름이 메소드 이름이며, 호출하면 일괄적으로 실행  
>
> 중복코드 제거, 관리 용이, 재사용 가능 
>
> 메세드 = 선언부 + 구현부  

[ 메소드의 구조 ] 

``` 
public 리턴자료형 메서드명(입력자료형1 입력변수1, 입력자료형2 입력변수2, ...) {
    ...    
    return 리턴값;  // 리턴자료형이 void 인 경우에는 return 문이 필요없다.
}  > 리턴자료형은 메서드 수행 후 돌려줄 값의 자료형을 의미한다. 메서드의 리턴값은 return 이라는 명령을 사용한다.
```



[메서드 호출 ] _  클래스 내외부의 호출에 의해 실행 

클래스 내부의 다른 메서드에서 호출할 경우, 단순한 메서드 이름으로 호출 되지만 외부에서 호출 할 경우 클래스로 부터 객체를 생성한 뒤 참조 변수를 이용해 

메서드를 호출 해야하고, 객체가 존재해야 메서드도 존재하기 때문.



## 메서드의 실행 흐름 #



``` 
math mm = new math();     //인스턴스 생성
long value = mm.add(1L,2L);  // 메소드 호출 

long add ( long a, long b ){
 	long result = a + b; 
 	return result; 
}
```

> 메인 메서드에서 메서드 add 를 호출 한다, 인수 1L과 2L이 메서드 add의 매개변수 a, b에 각각 대입된다
>
> 메서드 add의 괄호{ } 안에 있는 문장들이 순서대로 수행된다
>
> 메서드 add의 모든 문장이 실행되거나 return문을 만나면, 호출한 메서드로 되돌아와서 이후의 문장들을 실행 

* void : 리턴값이 없는 메소드는 리턴 타입으로 void를 기술 해야함
* 리턴문 :  선언부에 리턴타입이 있다면 리턴값을 지정하기 위해 return문이 반드시 있어야하고, void라면 필요 없지만 메서드 실행 종료를 위해 사용할수도 있다
* 오버로딩 :  클래스 내에 같은 이름의 메소드를 여러개 선언 하는 것을 메서드 오버로딩이라고 함, 메서드 오버로딩의 조건은 매개 변수의 타입, 개수, 순서 중 하나가 달라야 한다







* 인스턴스 멤버  :  인스턴스 멤버란 객체를 생성한 후 사용할 수 있는 필드와 메서드를 말하는데 이들을 각각 인스턴스필드, 인스턴스 메서드라고 부름 

* this : 객체 내부에서도 인스턴스 멥버에 접근하기 위해 this를 사용 할 수 있고, 예를 들어 this.model은 자신이 가지고 있는  model 필드라는 뜻, this는 주로 생성자와 메서드의 매개변수 이름이 필드와 동일한 경우 인스턴스 멤버인 필드임을 명시하고자 할때 사용 

* 정적 멤버 :  클래스에 고정된 멤버로서 객체를 생성하지 않고 사용 할 수 있는 필드와 메서드를 말하고, 정적 필드, 정적 메서드라고 함

* static 정적 멤버를 선언할 때 사용하는 키워드 

* 싱글톤 :  전체 프로그램에서 단 하나의 객체만 만들도록 보장해야하는 경우 하나만 생성된다고 해서 객체를 싱글톤이라고 함 

  > 싱글톤을 만들려면 클래스 외부에서 new 연산자로 생성자를 호출 할 수 없도록 막아햐 함, 생성자를 호출한 만큼 객체가 생성되기 때문, private 접근 제한자 붙여주면 됨
  >
  > > 코드 작성 
  > >
  > > ```
  > > public class 클래스 {
  > > 
  > > private static 클래스 singleton = new 클래스 ();  >>>>>>정적 필드 
  > > 
  > > private 클래스 () {} >>>>>>>>>생성자 
  > > 
  > > static 클래스 getInstance() {
  > >  return signleton; 
  > > }
  > > }
  > > ```





* 패키지 : 해당 클래스 또는 인터페이스가 어떤 패키지에 속할 것인지 선언하는 것 
* import문 : 사용하고자 하는 클래스 또는 인터페이스가 다른 패키지에 소속되어 있다면, import 문으로 해당 패키지의 클래스 또는 인터네이스를 가져와 사용할 것임을 컴파일러에게 알려줘야함 





# 접근 제한자

> 클래스와 인터페이스를 다른 패키지에서 사용하지 못하도록 막을 필요가 있고, 객체 생성을 막기 위해 생성자를 호출 하지 못하게 하거나 필드나 메서드를 사용하지 못하도록 막아야 하는 경우 >  접근자 사용
>
>  접근제한               적용대상                           접근할수 없는 클래스 
>
> public  >      클래스, 필드, 생성자, 메서드  >          없음 
>
> protected >   필드 , 생성자, 메서드  >               자식 클래스가 아닌 다른 패키지에 소속된 클래스 
>
> default >        클래스, 필드, 생성자, 메서드 >  다른 패키지에 소속된 클래스 
>
> private >       필드, 생성자, 메서드 >          모든 외부 클래스 



* getter / setter  :  필드는 외부에서 접근 할 수 없도록 막고 메서드는 공개해서 외부에서 메소드를 통해 필드에 접근하도록 유도, 필드의 값을 외부로 리턴 해주는 메서드를  getter, 외부에서 값을 받아 필드를 변경하는 메서드를 setter라고 함





## 